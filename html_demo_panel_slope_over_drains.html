<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>運動場局部排水系統 - 三角楔形暗渠（角度＋粒徑＋多水滴分裂）</title>
  <style>
    html, body { height:100%; margin:0; }
    body { background:#75b6e5; font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Ubuntu,Arial; }
    canvas { display:block; }
    #info { position:absolute; inset:10px 0 auto 0; text-align:center; color:#fff; font-weight:600; text-shadow:2px 2px 4px #000; pointer-events:none; }
    #panel { position:absolute; top:16px; left:16px; background:rgba(0,0,0,.55); color:#fff; border-radius:10px; padding:8px 12px; font-size:13px; }
    #panel .row{display:flex;align-items:center;gap:8px;margin-top:6px;}
    #panel input[type="range"], #panel select{flex:1;}
    #panel select, #panel button{background:rgba(255,255,255,.1);color:#fff;border:1px solid rgba(255,255,255,.25);border-radius:8px;padding:4px;cursor:pointer}
  </style>
</head>
<body>
  <div id="info">地表保持水平。暗渠為三角楔形，外端起點向中心井傾斜。角度 0–60° 可調。中心井與暗渠內填入不相互碰撞的半透明顆粒；水滴為紅色，支援多滴同時與分裂示意。</div>
  <div id="panel">
    <div class="row"><label>顯示綠色地表 <input type="checkbox" id="toggleGround" checked></label></div>
    <div class="row"><label for="slope">暗渠斜坡角度 (度)</label><input type="range" id="slope" min="0" max="60" step="1" value="10"><span id="slopeVal">10°</span></div>
    <div class="row"><label for="grain">粒徑 (mm)</label>
      <select id="grain" aria-label="粒徑">
        <option value="15" selected>15</option>
        <option value="30">30</option>
        <option value="50">50</option>
        <option value="70">70</option>
      </select>
    </div>
    <div class="row"><label for="dropSize">水滴粒徑 (mm)</label>
      <select id="dropSize" aria-label="水滴粒徑">
        <option value="10">10</option>
        <option value="15" selected>15</option>
        <option value="30">30</option>
      </select>
    </div>
    <div class="row">
      <button id="toggleDrop">水滴：播放</button>
      <button id="resetDropBtn">水滴：重設位置</button>
    </div>
  </div>

  <script type="importmap">
    {"imports": {"three": "https://unpkg.com/three@0.167.0/build/three.module.js","three/addons/": "https://unpkg.com/three@0.167.0/examples/jsm/"}}
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // ===== 參數 =====
    const groundRadius = 20;
    const wellRadius = 2.5, wellHeight = 15;
    const drainCount = 6;
    const drainLength = groundRadius - wellRadius;
    const drainWidth = 1.2, drainHeight = 1.5;

    let slopeAngle = 10 * Math.PI/180;            // 斜坡角度
    let grainMM = 15;                              // 顆粒粒徑（mm）
    let dropSizeMM = 15;                           // 水滴粒徑（mm）
    const MM_VISUAL = 0.02;                        // 1 mm → 0.02 場景單位（僅視覺）

    // ===== 渲染 =====
    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(devicePixelRatio||1,1.5));
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene(); scene.background = new THREE.Color(0x87ceeb);
    const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000); camera.position.set(15,18,24);
    const controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.06; controls.maxPolarAngle = Math.PI*0.495;
    scene.add(new THREE.AmbientLight(0xffffff, 0.9));

    // 地表
    const ground = new THREE.Mesh(new THREE.CircleGeometry(groundRadius, 128), new THREE.MeshLambertMaterial({ color:0x1e8b1e, transparent:true, opacity:0.6, side:THREE.DoubleSide }));
    ground.rotation.x = -Math.PI/2; scene.add(ground);
    const toggleGround = document.getElementById('toggleGround');
    if (toggleGround){ ground.visible = toggleGround.checked; toggleGround.addEventListener('change',()=>{ ground.visible = toggleGround.checked; }); }

    // 井
    const dryWell = new THREE.Mesh(new THREE.CylinderGeometry(wellRadius, wellRadius, wellHeight, 24), new THREE.MeshLambertMaterial({ color:0xaaaaaa, wireframe:true }));
    dryWell.position.y = -wellHeight/2 - 1; scene.add(dryWell);

    // ===== 三角楔形暗渠 =====
    const drains = new THREE.Group(); scene.add(drains);
    const drainMat = new THREE.MeshLambertMaterial({ color:0x654321, wireframe:true, transparent:true, opacity:0.75 });

    function makeWedgeGeometry(angleRad){
      const L = drainLength, W = drainWidth, H = drainHeight;
      const drop = Math.tan(angleRad) * L;         // 井端底面相對外端底面下降量
      const xI = -L/2, xO = +L/2;
      const zL = -W/2, zR = +W/2;
      const yTop = +H/2;                           // 頂面水平
      const yBotO = -H/2;                          // 外端底面
      const yBotI = -H/2 - drop;                   // 井端底面
      const pos = new Float32Array([
        // 上四點（水平不動）
        xI, yTop, zL,   xI, yTop, zR,   xO, yTop, zR,   xO, yTop, zL,
        // 下四點（外端固定，井端下降）
        xI, yBotI, zL,  xI, yBotI, zR,  xO, yBotO, zR,  xO, yBotO, zL
      ]);
      const idx = [ 0,1,2, 0,2,3, 4,7,6, 4,6,5, 0,3,7, 0,7,4, 1,5,6, 1,6,2, 0,4,5, 0,5,1, 3,2,6, 3,6,7 ];
      const g = new THREE.BufferGeometry(); g.setAttribute('position', new THREE.BufferAttribute(pos,3)); g.setIndex(idx); g.computeVertexNormals();
      return g;
    }

    function createDrain(angleRad){ return new THREE.Mesh(makeWedgeGeometry(angleRad), drainMat); }
    function updateDrainGeometry(mesh, angleRad){ const g = makeWedgeGeometry(angleRad); mesh.geometry.dispose(); mesh.geometry = g; }

    function buildDrains(){
      drains.clear();
      for (let i=0;i<drainCount;i++){
        const a = (i/drainCount)*Math.PI*2;
        const d = createDrain(slopeAngle);
        d.rotation.y = -a;
        const x = Math.cos(a)*(wellRadius + drainLength/2);
        const z = Math.sin(a)*(wellRadius + drainLength/2);
        d.position.set(x, -drainHeight/2 - 0.8, z);
        drains.add(d);
      }
    }
    buildDrains();

    // ===== 顆粒（井內 + 暗渠內） =====
    const MAX_INSTANCES = 24000;
    const pebbleMat = new THREE.MeshLambertMaterial({ color:0x2a2a2a, transparent:true, opacity:0.35, depthWrite:false });
    let pebbleGeom = new THREE.SphereGeometry(0.1, 8, 8); // 會依粒徑更新
    const pebbles = new THREE.InstancedMesh(pebbleGeom, pebbleMat, MAX_INSTANCES);
    pebbles.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    scene.add(pebbles);

    function radiusUnits(){ return (grainMM*MM_VISUAL)*0.5; } // 將 mm 轉為視覺半徑

    function countsForGrain(mm){
      // 小粒徑 → 更高密度；限制上限避免過慢
      const dens = Math.min(10, Math.max(1, 60/mm));
      const wellBase = 1600, drainBase = 420; // 30mm 約 1x 基準
      return { well: Math.floor(wellBase*dens), perDrain: Math.floor(drainBase*dens) };
    }

    // 拒絕取樣 + 最小距離檢查，避免顆粒重疊
    function seedWellNonOverlap(startIndex, count){
      const placed = []; const r = radiusUnits(); const minD2 = (2*r)*(2*r); let tries = 0; let idx = startIndex;
      while (placed.length < count && tries < count*80){
        tries++;
        const R = Math.random()*(wellRadius - r);
        const a = Math.random()*Math.PI*2;
        const x = Math.cos(a)*R;
        const z = Math.sin(a)*R;
        const y = -1 - r - Math.random()*(wellHeight - 2*r);
        let ok = true;
        for (let i=0;i<placed.length;i++){
          const p = placed[i]; const dx=x-p.x, dy=y-p.y, dz=z-p.z; if (dx*dx+dy*dy+dz*dz < minD2){ ok=false; break; }
        }
        if (!ok) continue;
        placed.push({x,y,z});
        const m = new THREE.Matrix4().setPosition(x,y,z);
        pebbles.setMatrixAt(idx++, m);
      }
      return idx;
    }

    function bottomYAtX(angleRad, x){
      const L = drainLength; const H = drainHeight; const drop = Math.tan(angleRad)*L; const t = (x + L/2)/L; const yBotI = -H/2 - drop; const yBotO = -H/2; return yBotI*(1-t) + yBotO*t;
    }

    function seedDrainNonOverlap(drainMesh, startIndex, count){
      const placed = []; const r = radiusUnits(); const minD2 = (2*r)*(2*r); let tries = 0; let idx = startIndex;
      while (placed.length < count && tries < count*100){
        tries++;
        const x = THREE.MathUtils.lerp(-drainLength/2 + r, drainLength/2 - r, Math.random());
        const z = THREE.MathUtils.lerp(-drainWidth/2 + r,  drainWidth/2 - r,  Math.random());
        const yMin = bottomYAtX(slopeAngle, x) + r; const yMax = +drainHeight/2 - r; if (yMin >= yMax) continue;
        const y = THREE.MathUtils.lerp(yMin, yMax, Math.random());
        let ok = true; for(let i=0;i<placed.length;i++){ const p=placed[i]; const dx=x-p.x, dy=y-p.y, dz=z-p.z; if(dx*dx+dy*dy+dz*dz < minD2){ ok=false; break; } }
        if (!ok) continue;
        placed.push({x,y,z});
        const wp = drainMesh.localToWorld(new THREE.Vector3(x,y,z));
        const m = new THREE.Matrix4().setPosition(wp);
        pebbles.setMatrixAt(idx++, m);
      }
      return idx;
    }

    function reseedAllPebbles(){
      const {well, perDrain} = countsForGrain(grainMM);
      let i = 0; i = seedWellNonOverlap(i, well);
      drains.children.forEach(d=>{ i = seedDrainNonOverlap(d, i, perDrain); });
      pebbles.count = i; pebbles.instanceMatrix.needsUpdate = true;
    }

    function updatePebbleGeometry(){ const newGeom = new THREE.SphereGeometry(radiusUnits(), 8, 8); pebbles.geometry.dispose(); pebbles.geometry = newGeom; }

    // 初始顆粒
    updatePebbleGeometry(); reseedAllPebbles();

    // ===== 多水滴（紅色，帶分裂） =====
    const BASE_DROP_R = 0.14; // 幾何基準半徑，之後用 scale 對應 mm
    function dropRadiusUnits(){ return (dropSizeMM*MM_VISUAL)*0.5; }

    class Drop {
      constructor(){
        this.mesh = new THREE.Mesh(new THREE.SphereGeometry(BASE_DROP_R, 16, 16), new THREE.MeshBasicMaterial({ color:0xff3b30 }));
        scene.add(this.mesh);
        this.mode = 'drain'; // 'drain' | 'well'
        this.drainIdx = 0;
        this.local = new THREE.Vector3(); // 暗渠局部
        this.world = new THREE.Vector3(); // 井內世界
        this.vy = 0;                      // 井內下落速度
        this.splitDone = false;           // 是否已分裂過（避免無限分裂）
        this.setRadius(dropRadiusUnits());
        this.randomizeStart();
      }
      setRadius(r){ const s = r/BASE_DROP_R; this.mesh.scale.setScalar(s); }
      placeAtDrain(i){
        this.mode='drain'; this.drainIdx=(i%drainCount+drainCount)%drainCount; this.vy=0; this.splitDone=false;
        this.local.set(drainLength/2 - 0.05, drainHeight/2 + 0.05, THREE.MathUtils.randFloatSpread(drainWidth*0.6));
        const d = drains.children[this.drainIdx]; const w = d.localToWorld(this.local.clone()); this.mesh.position.copy(w);
      }
      placeAtWell(){
        this.mode='well'; this.drainIdx=-1; this.vy=0; this.splitDone=false;
        const r = Math.random()*(wellRadius*0.6); const a = Math.random()*Math.PI*2; const x=Math.cos(a)*r, z=Math.sin(a)*r, y=-1 + 0.35;
        this.world.set(x,y,z); this.mesh.position.copy(this.world);
      }
      randomizeStart(){ Math.random()<0.5 ? this.placeAtDrain(Math.floor(Math.random()*drainCount)) : this.placeAtWell(); }
      params(){ const scale = Math.pow(grainMM/15, 1.4); return { v: 0.7*scale, k: 0.9*scale, g: 1.8*scale }; }
      trySplit(pool){
        if (this.splitDone) return;
        // 小粒徑越容易分裂；在暗渠中段機率較高
        if (this.mode!=='drain') return;
        const L=drainLength; const t=(this.local.x+L/2)/L; if (t<0.15 || t>0.85) return;
        const baseP = 0.6 * (30/Math.max(15, Math.min(70, grainMM))); // 15mm → 高；70mm → 低
        if (Math.random() < baseP*0.02){
          // 生成一個新水滴，兩者縮小到 70%
          this.splitDone = true;
          const child = new Drop();
          child.setRadius(dropRadiusUnits()*0.7); this.setRadius(dropRadiusUnits()*0.7);
          child.mode='drain'; child.drainIdx=this.drainIdx; child.local.copy(this.local); child.local.z += 0.08; // 微側向
          const d = drains.children[this.drainIdx]; const w = d.localToWorld(child.local.clone()); child.mesh.position.copy(w);
          pool.push(child);
        }
      }
      update(dt){
        const {v,k,g} = this.params();
        if (this.mode==='drain'){
          const d = drains.children[this.drainIdx];
          this.local.x -= v*dt; // 向井端
          const yTarget = bottomYAtX(slopeAngle, this.local.x) + 0.03;
          this.local.y += (yTarget - this.local.y) * Math.min(1, k*dt);
          const zig = (Math.random()-0.5) * 0.05 * Math.min(1, grainMM/30);
          this.local.z = THREE.MathUtils.clamp(this.local.z + zig, -drainWidth/2+0.05, drainWidth/2-0.05);
          this.trySplit(drops);
          const w = d.localToWorld(this.local.clone()); this.mesh.position.copy(w);
          if (this.local.x < -drainLength/2 + 0.05){ this.world.copy(w); this.mode='well'; this.vy=0; }
        } else {
          this.vy -= g*dt; this.world.y += this.vy*dt; // 下落
          this.world.x += (-this.world.x)*0.2*dt; this.world.z += (-this.world.z)*0.2*dt; // 向中心收斂
          const rad = Math.max(0.05, wellRadius - 0.2); const r2 = this.world.x*this.world.x + this.world.z*this.world.z; const r = Math.sqrt(r2); if (r>rad){ this.world.x *= rad/r; this.world.z *= rad/r; }
          this.mesh.position.copy(this.world);
          if (this.world.y < -wellHeight - 2){ this.randomizeStart(); this.setRadius(dropRadiusUnits()); }
        }
      }
      dispose(){ this.mesh.geometry.dispose(); this.mesh.material.dispose(); scene.remove(this.mesh); }
    }

    const drops = [];
    const INIT_DROPS = 4;
    const MAX_DROPS = 5;
    for (let i=0;i<INIT_DROPS;i++){ drops.push(new Drop()); }

    function clampDropCount(){
      // 保持不超過 MAX_DROPS
      while (drops.length > MAX_DROPS){ const d = drops.pop(); d.dispose(); }
    }

    // ===== 動畫 =====
    const clock = new THREE.Clock();
    let playDrop = false;
    function animate(){
      const dt = clock.getDelta();
      controls.update();
      if (playDrop){ drops.forEach(d=>d.update(dt)); clampDropCount(); }
      renderer.render(scene, camera);
    }
    renderer.setAnimationLoop(animate);

    // ===== 控制 =====
    const slopeInput = document.getElementById('slope');
    const slopeVal = document.getElementById('slopeVal');
    slopeInput.addEventListener('input', ()=>{
      slopeAngle = parseFloat(slopeInput.value) * Math.PI/180; slopeVal.textContent = slopeInput.value + '°';
      drains.children.forEach(m=>updateDrainGeometry(m, slopeAngle));
      reseedAllPebbles(); drops.forEach(d=>d.randomizeStart());
    });

    const grainSel = document.getElementById('grain');
    grainSel.addEventListener('change', ()=>{
      grainMM = parseFloat(grainSel.value);
      updatePebbleGeometry(); reseedAllPebbles(); drops.forEach(d=>d.randomizeStart());
    });

    const dropSizeSel = document.getElementById('dropSize');
    dropSizeSel.addEventListener('change', ()=>{
      dropSizeMM = parseFloat(dropSizeSel.value);
      drops.forEach(d=>d.setRadius(dropRadiusUnits()));
    });

    const toggleDropBtn = document.getElementById('toggleDrop');
    toggleDropBtn.addEventListener('click', ()=>{ playDrop = !playDrop; toggleDropBtn.textContent = playDrop ? '水滴：暫停' : '水滴：播放'; });

    const resetDropBtn = document.getElementById('resetDropBtn');
    resetDropBtn.addEventListener('click', ()=>{ drops.forEach(d=>d.randomizeStart()); while(drops.length>INIT_DROPS){ const x=drops.pop(); x.dispose(); } });

    // 初始：多滴就緒但暫停
    drops.forEach(d=>d.randomizeStart());

    // 響應式
    let rid=0; addEventListener('resize',()=>{ clearTimeout(rid); rid=setTimeout(()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setPixelRatio(Math.min(devicePixelRatio||1,1.5)); renderer.setSize(innerWidth,innerHeight); },100); });
  </script>
</body>
</html>
